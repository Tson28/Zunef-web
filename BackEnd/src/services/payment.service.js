const Payment = require('../models/payment.model');
const User = require('../models/user.model');
const orderService = require('./order.service');
const crypto = require('crypto');

class PaymentService {
    // T·∫°o ƒë∆°n h√†ng thanh to√°n m·ªõi
    async createPayment(userId, items, customerInfo) {
        try {
            // T√≠nh t·ªïng ti·ªÅn
            const totalAmount = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            
            // T·∫°o m√£ ƒë∆°n h√†ng v√† m√£ giao d·ªãch unique
            const orderId = this.generateOrderId();
            const transactionCode = this.generateTransactionCode();
            
            // T·∫°o n·ªôi dung chuy·ªÉn kho·∫£n
            const qrContent = `ZUNEF_${transactionCode}`;
            
            // T·∫°o URL QR code SePay
            const qrUrl = this.generateSepayQRUrl(totalAmount, qrContent);
            
            // Th√™m productType v√†o items n·∫øu ch∆∞a c√≥
            const enhancedItems = await this.enhanceItemsWithProductType(items);
            
            const payment = new Payment({
                orderId,
                userId,
                items: enhancedItems,
                amount: totalAmount,
                transactionCode,
                bankInfo: {
                    accountNumber: '0915878677',
                    bankName: 'MB',
                    qrContent: qrUrl
                },
                customerInfo,
                status: 'pending'
            });
            
            await payment.save();
            return payment;
        } catch (error) {
            throw new Error(`L·ªói t·∫°o ƒë∆°n h√†ng: ${error.message}`);
        }
    }
    
    // T·∫°o URL QR code SePay
    generateSepayQRUrl(amount, content) {
        const accountNumber = '0915878677';
        const bankName = 'MB';
        const encodedContent = encodeURIComponent(content);
        
        return `https://qr.sepay.vn/img?acc=${accountNumber}&bank=${bankName}&amount=${amount}&des=${encodedContent}`;
    }
    
    // T·∫°o m√£ ƒë∆°n h√†ng
    generateOrderId() {
        const timestamp = Date.now().toString();
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `ORD_${timestamp}_${random}`;
    }
    
    // T·∫°o m√£ giao d·ªãch
    generateTransactionCode() {
        const timestamp = Date.now().toString().slice(-8);
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `${timestamp}${random}`;
    }
    
    // X·ª≠ l√Ω webhook t·ª´ SePay
    async processWebhook(webhookData) {
        try {
            const { content, transferAmount, gateway, transactionDate, accountNumber, referenceCode, id } = webhookData;
            
            // T√¨m m√£ giao d·ªãch t·ª´ n·ªôi dung chuy·ªÉn kho·∫£n
            // Pattern: ZUNEF theo sau b·ªüi m√£ giao d·ªãch
            const transactionCodeMatch = content.match(/ZUNEF([A-Z0-9]+)/);
            if (!transactionCodeMatch) {
                throw new Error('Kh√¥ng t√¨m th·∫•y m√£ giao d·ªãch trong n·ªôi dung chuy·ªÉn kho·∫£n');
            }
            
            const transactionCode = transactionCodeMatch[1];
            console.log('Extracted transaction code:', transactionCode);
            
            // T√¨m ƒë∆°n h√†ng theo m√£ giao d·ªãch
            const payment = await Payment.findOne({ 
                transactionCode,
                status: 'pending'
            });
            
            if (!payment) {
                throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c ƒë∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω');
            }
            
            // Ki·ªÉm tra s·ªë ti·ªÅn
            if (transferAmount !== payment.amount) {
                throw new Error(`S·ªë ti·ªÅn kh√¥ng kh·ªõp. Y√™u c·∫ßu: ${payment.amount}, Nh·∫≠n ƒë∆∞·ª£c: ${transferAmount}`);
            }
            
            // C·∫≠p nh·∫≠t th√¥ng tin thanh to√°n
            payment.status = 'completed';
            payment.paymentDate = new Date();
            payment.sepayTransactionId = id.toString();
            payment.webhookData = {
                gateway,
                transactionDate,
                accountNumber,
                content,
                transferType: webhookData.transferType,
                description: webhookData.description,
                transferAmount,
                referenceCode,
                sepayId: id
            };
            
            await payment.save();
            
            console.log('üíæ Payment saved, now creating orders...');
            
            // T·∫°o ƒë∆°n h√†ng ri√™ng l·∫ª cho t·ª´ng s·∫£n ph·∫©m
            let orders = [];
            try {
                console.log('üîÑ Calling orderService.createOrdersFromPayment...');
                orders = await orderService.createOrdersFromPayment(payment);
                console.log('‚úÖ Orders created successfully:', orders.length);
            } catch (orderError) {
                console.error('‚ùå Error creating orders:', orderError.message);
                console.error('‚ùå Order error stack:', orderError.stack);
                // Kh√¥ng throw error ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n qu√° tr√¨nh thanh to√°n
            }
            
            console.log('üì¶ Orders result:', orders.length, 'orders created');
            
            // C·∫≠p nh·∫≠t ownership cho user n·∫øu c√≥ source code trong ƒë∆°n h√†ng
            await this.updateUserOwnership(payment);
            
            return {
                success: true,
                message: 'Thanh to√°n ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng',
                orderId: payment.orderId,
                payment,
                orders
            };
        } catch (error) {
            throw new Error(`L·ªói x·ª≠ l√Ω webhook: ${error.message}`);
        }
    }
    
    // C·∫≠p nh·∫≠t ownership cho user khi mua source code v√† t·∫°o UserAccountInfo cho account
    async updateUserOwnership(payment) {
        try {
            // L·∫•y danh s√°ch productId t·ª´ payment items
            const productIds = payment.items.map(item => item.productId);
            
            if (productIds.length > 0) {
                // Ki·ªÉm tra xem productId n√†o l√† source code
                const SourceCode = require('../models/sourceCode.model');
                const validSourceCodes = await SourceCode.find({ 
                    _id: { $in: productIds } 
                }).select('_id');
                
                const validSourceCodeIds = validSourceCodes.map(sc => sc._id.toString());
                
                if (validSourceCodeIds.length > 0) {
                    // C·∫≠p nh·∫≠t ownership cho user
                    await User.findByIdAndUpdate(
                        payment.userId,
                        { 
                            $addToSet: { 
                                ownership: { $each: validSourceCodeIds } 
                            } 
                        }
                    );
                    
                    console.log(`Updated ownership for user ${payment.userId} with source codes:`, validSourceCodeIds);
                }
                
                // T·∫°o UserAccountInfo cho account products
                await this.createUserAccountInfo(payment);
            }
        } catch (error) {
            console.error('L·ªói c·∫≠p nh·∫≠t ownership:', error.message);
            // Kh√¥ng throw error ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n qu√° tr√¨nh thanh to√°n
        }
    }
    
    // T·∫°o UserAccountInfo cho account products
    async createUserAccountInfo(payment) {
        try {
            const UserAccountInfo = require('../models/userAccountInfo.model');
            const Account = require('../models/account.model');
            const SourceCode = require('../models/sourceCode.model');
            
            for (const item of payment.items) {
                let productType = item.productType;
                
                // T·ª± ƒë·ªông x√°c ƒë·ªãnh productType n·∫øu ch∆∞a c√≥
                if (!productType) {
                    // Ki·ªÉm tra trong SourceCode collection tr∆∞·ªõc
                    const sourceCode = await SourceCode.findById(item.productId);
                    if (sourceCode) {
                        productType = 'source-code';
                    } else {
                        // Ki·ªÉm tra trong Account collection
                        const account = await Account.findById(item.productId);
                        if (account) {
                            productType = 'account';
                        }
                    }
                }
                
                // Ki·ªÉm tra xem item c√≥ ph·∫£i l√† account product kh√¥ng
                if (productType === 'account') {
                    const account = await Account.findById(item.productId);
                    if (account) {
                        // Ki·ªÉm tra xem ƒë√£ c√≥ UserAccountInfo ch∆∞a
                        const existingInfo = await UserAccountInfo.findOne({
                            userId: payment.userId,
                            orderId: payment.orderId,
                            productId: item.productId
                        });
                        
                        if (!existingInfo) {
                            // T·∫°o UserAccountInfo record
                            const userAccountInfo = await UserAccountInfo.createFromOrder({
                                userId: payment.userId,
                                orderId: payment.orderId,
                                productId: item.productId,
                                productName: item.productName || item.title || account.name,
                                duration: account.duration
                            });
                            
                            console.log(`‚úÖ Created UserAccountInfo for user ${payment.userId}, order ${payment.orderId}, product ${account.name}`);
                        } else {
                            console.log(`‚è≠Ô∏è  UserAccountInfo already exists for order ${payment.orderId}, product ${item.productId}`);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå L·ªói t·∫°o UserAccountInfo:', error.message);
            // Kh√¥ng throw error ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n qu√° tr√¨nh thanh to√°n
        }
    }
    
    // L·∫•y th√¥ng tin thanh to√°n theo orderId
    async getPaymentByOrderId(orderId, populateUser = false) {
        try {
            let query = Payment.findOne({ orderId });
            if (populateUser) {
                query = query.populate('userId', 'name email');
            }
            const payment = await query;
            if (!payment) {
                throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
            }
            return payment;
        } catch (error) {
            throw new Error(`L·ªói l·∫•y th√¥ng tin thanh to√°n: ${error.message}`);
        }
    }
    
    // L·∫•y th√¥ng tin thanh to√°n theo transactionCode
    async getPaymentByTransactionCode(transactionCode) {
        try {
            const payment = await Payment.findOne({ transactionCode }).populate('userId', 'name email');
            return payment; // Return null if not found, let controller handle it
        } catch (error) {
            throw new Error(`L·ªói l·∫•y th√¥ng tin giao d·ªãch: ${error.message}`);
        }
    }
    
    // L·∫•y danh s√°ch thanh to√°n c·ªßa user
    async getUserPayments(userId, page = 1, limit = 10) {
        try {
            const skip = (page - 1) * limit;
            const payments = await Payment.find({ userId })
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(limit)
                .populate('userId', 'name email');
                
            // Enhance items with productType for payments that might not have it
            const enhancedPayments = await Promise.all(
                payments.map(async (payment) => {
                    const paymentObj = payment.toObject();
                    if (paymentObj.items && paymentObj.items.length > 0) {
                        // Check if any item is missing productType
                        const needsEnhancement = paymentObj.items.some(item => !item.productType);
                        if (needsEnhancement) {
                            paymentObj.items = await this.enhanceItemsWithProductType(paymentObj.items);
                        }
                    }
                    return paymentObj;
                })
            );
                
            const total = await Payment.countDocuments({ userId });
            
            return {
                payments: enhancedPayments,
                pagination: {
                    page,
                    limit,
                    total,
                    pages: Math.ceil(total / limit)
                }
            };
        } catch (error) {
            throw new Error(`L·ªói l·∫•y danh s√°ch thanh to√°n: ${error.message}`);
        }
    }
    
    // H·ªßy ƒë∆°n h√†ng
    async cancelPayment(orderId, userId) {
        try {
            const payment = await Payment.findOne({ orderId, userId, status: 'pending' });
            if (!payment) {
                throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c ƒë∆°n h√†ng kh√¥ng th·ªÉ h·ªßy');
            }
            
            payment.status = 'cancelled';
            await payment.save();
            
            return payment;
        } catch (error) {
            throw new Error(`L·ªói h·ªßy ƒë∆°n h√†ng: ${error.message}`);
        }
    }
    
    // Ki·ªÉm tra ƒë∆°n h√†ng h·∫øt h·∫°n
    async checkExpiredPayments() {
        try {
            const expiredPayments = await Payment.updateMany(
                {
                    status: 'pending',
                    expiresAt: { $lt: new Date() }
                },
                {
                    status: 'cancelled'
                }
            );
            
            return expiredPayments;
        } catch (error) {
            throw new Error(`L·ªói ki·ªÉm tra ƒë∆°n h√†ng h·∫øt h·∫°n: ${error.message}`);
        }
    }
    
    // Th√™m productType v√†o items
    async enhanceItemsWithProductType(items) {
        try {
            const SourceCode = require('../models/sourceCode.model');
            const Account = require('../models/account.model');
            
            const enhancedItems = [];
            
            for (const item of items) {
                let productType = item.productType;
                
                // N·∫øu ch∆∞a c√≥ productType, t·ª± ƒë·ªông x√°c ƒë·ªãnh
                if (!productType) {
                    // Ki·ªÉm tra trong SourceCode collection
                    const sourceCode = await SourceCode.findById(item.productId);
                    if (sourceCode) {
                        productType = 'source-code';
                    } else {
                        // Ki·ªÉm tra trong Account collection
                        const account = await Account.findById(item.productId);
                        if (account) {
                            productType = 'account';
                        } else {
                            // Default fallback
                            productType = 'source-code';
                        }
                    }
                }
                
                enhancedItems.push({
                    ...item,
                    productType
                });
            }
            
            return enhancedItems;
        } catch (error) {
            console.error('Error enhancing items with productType:', error);
            // Fallback: return items with default productType
            return items.map(item => ({
                ...item,
                productType: item.productType || 'source-code'
            }));
        }
    }
}

module.exports = new PaymentService();